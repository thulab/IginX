package cn.edu.tsinghua.iginx.jdbc;

import cn.edu.tsinghua.iginx.exceptions.ExecutionException;
import cn.edu.tsinghua.iginx.exceptions.SessionException;
import cn.edu.tsinghua.iginx.session.Session;
import cn.edu.tsinghua.iginx.session.SessionExecuteSqlResult;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

public class IginXStatement implements Statement {

    private IginXConnection connection;
    private Session session;
    private boolean isClosed;
    private SQLWarning warningChain; // Not used for now.

    private List<String> batchSQLList;
    private ResultSet resultSet;

    public IginXStatement(IginXConnection connection, Session session) {
        this.connection = connection;
        this.session = session;
        this.batchSQLList = new ArrayList<>();
        this.isClosed = false;
        this.warningChain = null;
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        checkConnection("executeQuery");
        executeSQL(sql);
        return this.resultSet;
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        checkConnection("executeUpdate");
        executeSQL(sql);
        return SUCCESS_NO_INFO;
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        checkConnection("execute");
        executeSQL(sql);
        return sql.trim().toLowerCase().startsWith(Constant.SELECT_CLAUSE_PREFIX) ||
                sql.trim().toLowerCase().startsWith(Constant.SHOW_CLAUSE_PREFIX);
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    private void executeSQL(String sql) throws SQLException {
        try {
            SessionExecuteSqlResult res = session.executeSql(sql);
            this.resultSet = new IginXResultSet(this, res);
        } catch (SessionException | ExecutionException e) {
            throw new SQLException(String.format("Fail to execute %s", sql), e);
        }
    }

    @Override
    public int[] executeBatch() throws SQLException {
        checkConnection("executeBatch");

        if (batchSQLList == null || batchSQLList.size() == 0) {
            return new int[0];
        }

        int[] res = new int[batchSQLList.size()];
        for (int i = 0; i < batchSQLList.size(); i++) {
            String sql = batchSQLList.get(i);
            try {
                session.executeSql(sql);
                res[i] = SUCCESS_NO_INFO;
            } catch (SessionException | ExecutionException e) {
                res[i] = EXECUTE_FAILED;
            }
        }
        return res;
    }

    @Override
    public void addBatch(String sql) throws SQLException {
        if (batchSQLList == null) {
            batchSQLList = new ArrayList<>();
        }

        boolean isQuery = sql.trim().toLowerCase().startsWith(Constant.SELECT_CLAUSE_PREFIX) ||
                sql.trim().toLowerCase().startsWith(Constant.SHOW_CLAUSE_PREFIX);
        if (isQuery) {
            throw new SQLException("Batch query is not supported.");
        } else {
            batchSQLList.add(sql);
        }
    }

    @Override
    public void clearBatch() {
        if (batchSQLList == null) {
            batchSQLList = new ArrayList<>();
        }
        batchSQLList.clear();
    }

    // Only for test.
    public List<String> getBatchSQLList() {
        return batchSQLList;
    }

    private void checkConnection(String action) throws SQLException {
        if (connection == null || connection.isClosed()) {
            throw new SQLException(String.format("Cannot %s after connection has been closed!", action));
        }
        if (isClosed()) {
            throw new SQLException(String.format("Cannot %s after statement has been closed!", action));
        }
    }

    @Override
    public Connection getConnection() {
        return connection;
    }

    @Override
    public void close() {
        if (isClosed) {
            return;
        }
        this.isClosed = true;
    }

    @Override
    public ResultSet getResultSet() throws SQLException {
        checkConnection("getResultSet");
        return resultSet;
    }

    @Override
    public boolean isClosed() {
        return isClosed;
    }

    @Override
    public SQLWarning getWarnings() {
        return warningChain;
    }

    @Override
    public void clearWarnings() {
        warningChain = null;
    }

    @Override
    public int getResultSetType() throws SQLException {
        checkConnection("getResultSetType");
        return ResultSet.TYPE_FORWARD_ONLY;
    }

    @Override
    public int getFetchDirection() throws SQLException {
        checkConnection("getFetchDirection");
        return ResultSet.FETCH_FORWARD;
    }

    @Override
    public void setFetchDirection(int direction) throws SQLException {
        checkConnection("setFetchDirection");
        if (direction != ResultSet.FETCH_FORWARD) {
            throw new SQLException(String.format("direction %d is not supported!", direction));
        }
    }

    @Override
    public int getMaxFieldSize() throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public void setMaxFieldSize(int max) throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public int getMaxRows() throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public void setMaxRows(int max) throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public void setEscapeProcessing(boolean enable) throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public int getQueryTimeout() throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public void setQueryTimeout(int seconds) throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public void cancel() throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public void setCursorName(String name) throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public int getUpdateCount() {
        return -1;
    }

    @Override
    public boolean getMoreResults() {
        return false;
    }

    @Override
    public int getFetchSize() throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public void setFetchSize(int rows) throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public int getResultSetConcurrency() throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public boolean getMoreResults(int current) {
        return false;
    }

    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public int getResultSetHoldability() throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public boolean isPoolable() throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public void setPoolable(boolean poolable) throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public void closeOnCompletion() throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public boolean isCloseOnCompletion() throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public <T> T unwrap(Class<T> iface) throws SQLException {
        throw new SQLException(Constant.METHOD_NOT_SUPPORTED);
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) {
        return false;
    }
}
